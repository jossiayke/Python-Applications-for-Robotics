<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scripts.bot_controller.bot_controller_class API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scripts.bot_controller.bot_controller_class</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

from genericpath import exists
import rospy
import sys
#import tf

from nav_msgs.msg import Odometry
#from tf.transformations import euler_from_quaternion, quaternion_from_euler
from math import sqrt, atan2, pi
#import tf2_ros
from std_srvs.srv import Empty
from gazebo_ros_link_attacher.srv import Attach, AttachRequest
from gazebo_msgs.srv import SpawnModel, SpawnModelRequest, DeleteModel
from enpm809e_msgs.msg import PartInfo, PartInfos, LogicalCameraImage, Model
from gazebo_msgs.msg import ModelStates
from geometry_msgs.msg import Quaternion, Pose, TransformStamped, Twist, Point
from bot_controller.part_class import Part


class BotController(object):
    &#34;&#34;&#34;
    A controller class to drive a turtlebot in Gazebo.
    
    Args:
        self._is_part_info_gathered: (bool) - sets True if parts info obtained
        self._part_list: (list) - stores parts qued to be moved
        self._camera_parts: (list) - stores parts sensed by cameras
        self._cam_dict: (dict)  - stoes camera number with associated part
        self._queried_camera_1: (bool) - sets True if camera data has been processed
        self._queried_camera_2: (bool) - sets True if camera data has been processed
        self._queried_camera_3: (bool) - sets True if camera data has been processed
        self._queried_camera_4: (bool) - sets True if camera data has been processed
        self._rate: (rospy.Rate) - used to assign rate to publishing data
        self._robot_name: (str) -  stores robot name
        self._velocity_msg: (Twist)  -  used to store linear and angular robot velocity
        self._kp_linear: (float) -  stores linear proportional controller
        self._kp_angular: (float) -  stores angular proportional controller
        self._current_x_pos: (float) - stores current robot x position
        self._current_y_pos: (float) - stores current robot y position
        self._current_orientation: (float) - stores robot current orientation as quaternion
        self._initial_orientation: (float) - stores robot initial orientation as quaternion
        self._goal_reached: (bool)  -  sets to True when robot reaches goal
        self._velocity_publisher: (Twist)  -  publishes robot velocity to cmd_vel
        self._camera1_msg: (Rosmsg) -  stores part type, pose, and camera pose info
        self._camera2_msg: (Rosmsg) -  stores part type, pose, and camera pose info
        self._camera3_msg: (Rosmsg) -  stores part type, pose, and camera pose info
        self._camera4_msg: (Rosmsg) -  stores part type, pose, and camera pose info
        
    Return:
        None
    &#34;&#34;&#34;

    def __init__(self, rate=10):
        &#34;&#34;&#34;
        Initializes BotController object with the following attributes

        Args:
            rate (int, optional): _description_. Defaults to 10.
            
        Return:
            None
        &#34;&#34;&#34;
        
        rospy.init_node(&#39;bot_controller&#39;)
        rospy.loginfo(&#39;Press Ctrl c to exit&#39;)
        self._is_part_info_gathered = False
        self._part_list = []
        self._camera_parts = []
        self._cam_dict = {}

        #  used to check whether a camera data has been processed
        self._queried_camera_1 = False
        self._queried_camera_2 = False
        self._queried_camera_3 = False
        self._queried_camera_4 = False
        
        self._rate = rospy.Rate(rate)
        self._robot_name = &#39;waffle&#39;
        self._velocity_msg = Twist()
        
        #  gains for the proportional controller
        self._kp_linear = 0.2
        self._kp_angular = 0.2

        #  default velocities for going in a straight line
        self._velocity_msg.linear.x = 0.1
        self._velocity_msg.angular.z = 0.1

        # current pose of the robot
        self._current_x_pos = None
        self._current_y_pos = None
        self._current_orientation = None
        self._initial_orientation = None

        #  used to check whether the goal has been reached
        self._goal_reached = False

        # Publishers
        self._velocity_publisher = rospy.Publisher(
            &#39;cmd_vel&#39;, Twist, queue_size=10)
        
        # Subscribers
        self.subscribe()
    
        # Save parts queue from /part_infos
        self._parts_list = self._part_infos_msg.part_infos
        
        # Execute action to deliver parts to their drop location
        self.delivery()
        rospy.spin()

    @staticmethod
    def compute_distance(x1, y1, x2, y2):
        &#34;&#34;&#34;Compute distance between 2 points

        Args:
            x1 (float): x position of the first point
            y1 (float): y position of the first point
            x2 (float): x position of the second point
            y2 (float): y position of the second point

        Returns:
            float: distance between 2 points
        &#34;&#34;&#34;
        return sqrt(((x2-x1)**2) + ((y2-y1)**2))

    @staticmethod
    def get_model_pose(model_name=&#34;waffle&#34;):
        &#34;&#34;&#34;
        Get the pose of the turtlebot in the environment.
        This function is used by the method attach_part

        Args:
            model_name (str, optional): Name of the robot model in Gazebo. Defaults to &#34;waffle&#34;.

        Raises:
            RuntimeError: Raised when the robot model cannot be retrieved

        Returns:
            Pose: Pose of the robot in the Gazebo world
        &#34;&#34;&#34;
        poll_rate = rospy.Rate(1)
        for i in range(10):
            model_states = rospy.wait_for_message(
                &#39;/gazebo/model_states&#39;, ModelStates, 1)
            if model_name in model_states.name:
                model_pose = model_states.pose[model_states.name.index(
                    model_name)]
                break
            poll_rate.sleep()
        else:
            raise RuntimeError(&#39;Failed to get &#39; + model_name + &#39; model state&#39;)
        return model_pose

    def subscribe(self):
        &#34;&#34;&#34;
        Subscribe to /odom, all four cameras, and /part_infos
        
        Args:
            None
            
        Return:
            None 
        &#34;&#34;&#34;
        rospy.Subscriber(&#34;/odom&#34;, Odometry, self.odom_callback)

        rospy.Subscriber(&#34;/logical_camera/camera_1&#34;,
                         LogicalCameraImage, self.camera_1_callback)
        self._camera1_msg = rospy.wait_for_message(&#39;/logical_camera/camera_1&#39;, LogicalCameraImage)
        rospy.loginfo(self._camera1_msg)
        
        if self._camera1_msg is not None:
            model = self._camera1_msg.models[0]
            self._cam_dict[str(model.type)] = &#39;1&#39;
        else:
            self._camera_parts.append(None)

        rospy.Subscriber(&#34;/logical_camera/camera_2&#34;,
                         LogicalCameraImage, self.camera_2_callback)
        self._camera2_msg = rospy.wait_for_message(&#39;/logical_camera/camera_2&#39;, LogicalCameraImage)
        
        rospy.loginfo(self._camera2_msg)
        if self._camera2_msg is not None:
            model = self._camera2_msg.models[0]
            self._cam_dict[str(model.type)] = &#39;2&#39;
        else:
            self._camera_parts.append(None)
            
        rospy.Subscriber(&#34;/logical_camera/camera_3&#34;,
                         LogicalCameraImage, self.camera_3_callback)
        self._camera3_msg = rospy.wait_for_message(&#39;/logical_camera/camera_3&#39;, LogicalCameraImage)
        rospy.loginfo(self._camera3_msg)
        
        if self._camera3_msg is not None:
            model = self._camera3_msg.models[0]
            self._cam_dict[str(model.type)] = &#39;3&#39;
        else:
            self._camera_parts.append(None)
            
        rospy.Subscriber(&#34;/logical_camera/camera_4&#34;,
                         LogicalCameraImage, self.camera_4_callback)
        self._camera4_msg = rospy.wait_for_message(&#39;/logical_camera/camera_4&#39;, LogicalCameraImage)
        rospy.loginfo(self._camera4_msg)
        
        if self._camera4_msg is not None:
            model = self._camera4_msg.models[0]
            self._cam_dict[str(model.type)] = &#39;4&#39;
        else:
            self._camera_parts.append(None)
            
        self._part_infos_msg = rospy.wait_for_message(&#39;/part_infos&#39;, PartInfos)
        rospy.loginfo(self._part_infos_msg)
        
    def attach_part(self, part_type):
        &#34;&#34;&#34;
        Attach a Gazebo model to the turtlebot
        
        Args:
        
            part_type: (str) - type of part to attach
            
        Return:
        
            None
        &#34;&#34;&#34;
        part_name = part_type+&#34;_1&#34;
        rospy.loginfo(part_name)

        pause_physics_client = rospy.ServiceProxy(
            &#39;/gazebo/pause_physics&#39;, Empty)
        unpause_physics_client = rospy.ServiceProxy(
            &#39;/gazebo/unpause_physics&#39;, Empty)
        spawn_sdf_model_client = rospy.ServiceProxy(
            &#39;/gazebo/spawn_sdf_model&#39;, SpawnModel)
        link_attacher_client = rospy.ServiceProxy(
            &#39;/link_attacher_node/attach&#39;, Attach)
        delete_model_client = rospy.ServiceProxy(
            &#39;gazebo/delete_model&#39;, DeleteModel)
        
        # Remove from Gazebo
        delete_model_client(part_type+&#34;_0&#34;)

        # Compute part pose based on current robot pose
        part_pose = BotController.get_model_pose(self._robot_name)
        rospy.loginfo(part_pose.position.x)
        rospy.loginfo(part_pose.position.y)
        rospy.logwarn(self._robot_name)
        # part_pose.position.x -= 0.05
        part_pose.position.y += 0.5
        part_pose.position.z += 0.3

        model_name = &#34;model://&#34;+part_type+&#34;_ariac&#34;
        rospy.loginfo(&#34;Model: {}&#34;.format(model_name))
        
        # Compute spawn model request
        spawn_request = SpawnModelRequest()
        spawn_request.model_name = part_name
        
        # spawn_request.model_name = &#34;assembly_pump_yellow_0&#34;
        spawn_request.model_xml = &#39;&lt;sdf version=&#34;1.6&#34;&gt; \
        &lt;world name=&#34;default&#34;&gt; \
            &lt;include&gt; \
                &lt;uri&gt;{0}&lt;/uri&gt; \
            &lt;/include&gt; \
            &lt;/world&gt; \
        &lt;/sdf&gt;&#39;.format(model_name)
        spawn_request.robot_namespace = self._robot_name
        spawn_request.initial_pose = part_pose

        # Pause Gazebo
        try:
            pause_physics_client()
        except rospy.ServiceException as e:
            rospy.logerr(&#34;Pause physics service call failed: %s&#34;, e)

        spawn_sdf_model_client(spawn_request)

        #  Attach the part to the robot
        try:
            link_attacher_client(
                self._robot_name, &#39;base_footprint&#39;, part_name, &#39;link&#39;)
        except rospy.ServiceException as e:
            rospy.logerr(&#34;Link attacher service call failed: %s&#34;, e)

        #  Unpause Gazebo
        try:
            unpause_physics_client()
        except rospy.ServiceException as e:
            rospy.logerr(&#34;Unpause physics service call failed: %s&#34;, e)

    def detach_part(self, part_type):
        &#34;&#34;&#34;
        Detach a model from the turtlebot
        
        Arg:
            part_type: (str) - name of part type to be detached
            
        Return:
            None
        &#34;&#34;&#34;
        
        detach_client = rospy.ServiceProxy(&#39;/link_attacher_node/detach&#39;,
                                           Attach)
        detach_client.wait_for_service()

        part_name = part_type+&#34;_1&#34;

        # Build the detach request
        rospy.loginfo(&#34;Detaching part from robot&#34;)
        req = AttachRequest()
        req.model_name_1 = self._robot_name
        req.link_name_1 = &#34;base_footprint&#34;
        req.model_name_2 = part_name
        req.link_name_2 = &#34;link&#34;

        detach_client.call(req)

    def camera_1_callback(self, msg):
        &#34;&#34;&#34;
        Callback for Topic /logical_camera/camera_1
        
        Arg:
            msg: (str) - message from /part_info
            
        Return:
            None
        &#34;&#34;&#34;
        
        model = msg.models
        
        if not self._queried_camera_1:
           
            camera_part = Part(
                    model[0].type, &#34;camera_1_&#34;+model[0].type+&#34;_0_frame&#34;, model[0].pose)
            self._camera_parts.append(camera_part)
            self._queried_camera_1 = True

    def camera_2_callback(self, msg): 
        &#34;&#34;&#34;
        Callback for Topic /logical_camera/camera_2
        
        Arg:
            msg: (str) - message from /part_info
            
        Return:
            None
        &#34;&#34;&#34;
        
        model = msg.models
        
        if not self._queried_camera_2:
            
            camera_part = Part(
                    model[0].type, &#34;camera_2_&#34;+ model[0].type+&#34;_0_frame&#34;, model[0].pose)
            self._camera_parts.append(camera_part)
            self._queried_camera_2 = True
            
    def camera_3_callback(self, msg): 
        &#34;&#34;&#34;
        Callback for Topic /logical_camera/camera_3
        
        Arg:
            msg: (str) - message from /part_info
            
        Return:
            None
        &#34;&#34;&#34;
        
        model = msg.models
        
        if not self._queried_camera_3:
            
            camera_part = Part(
                    model[0].type, &#34;camera_3_&#34;+ model[0].type+&#34;_0_frame&#34;, model[0].pose)
            self._camera_parts.append(camera_part)
            self._queried_camera_3 = True
            
    def camera_4_callback(self, msg):
        &#34;&#34;&#34;
        Callback for Topic /logical_camera/camera_4
        
        Arg:
            msg: (str) - message from /part_info
            
        Return:
            None
        &#34;&#34;&#34;
        
        model = msg.models
        
        if not self._queried_camera_4:
            
            camera_part = Part(
                    model[0].type, &#34;camera_4_&#34;+ model[0].type+&#34;_0_frame&#34;, model[0].pose)
            self._camera_parts.append(camera_part)
            self._queried_camera_4 = True
            
    def odom_callback(self, msg):
        &#34;&#34;&#34;
        Callback function for the Topic odom
        
        Args:
            msg (nav_msgs/Odometry): Odometry message
            
        Return:
            None
        &#34;&#34;&#34;
        
        quaternion = (msg.pose.pose.orientation.x, msg.pose.pose.orientation.y,
                      msg.pose.pose.orientation.z, msg.pose.pose.orientation.w)

        self._current_x_pos = msg.pose.pose.position.x
        self._current_y_pos = msg.pose.pose.position.y
        self._current_orientation = euler_from_quaternion(quaternion)

    def get_transform(self, source, target):
        &#34;&#34;&#34;Get the transform between two frames

        Args:
            source (str): source frame
            target (str): target frame

        Returns:
            geometry_msgs/Pose: The pose of the source frame in the target frame
        &#34;&#34;&#34;
        
        tf_buffer = tf2_ros.Buffer(rospy.Duration(3.0))
        tf2_ros.TransformListener(tf_buffer)

        transform_stamped = TransformStamped()

        rospy.logwarn(&#34;Source: {}&#34;.format(source))
        rospy.logwarn(&#34;Target: {}&#34;.format(target))

        try:
            transform_stamped = tf_buffer.lookup_transform(
                target,
                source,
                rospy.Time(),
                rospy.Duration(1.0))
        except (tf2_ros.LookupException,
                tf2_ros.ConnectivityException,
                tf2_ros.ExtrapolationException):
            rospy.logerr(&#34;Unable to lookup transform&#34;)

        pose = Pose()
        pose.position = transform_stamped.transform.translation
        rospy.logwarn(&#34;Transform: {}&#34;.format(pose))
        pose.orientation = transform_stamped.transform.rotation
        return pose

    def go_to_goal(self, goal_x, goal_y):
        &#34;&#34;&#34;
        Make the robot reach a 2D goal using a proportional controller
        
        Args:
            goal_x (float): x position
            goal_y (float): y position
            
        Return:
            None
        &#34;&#34;&#34;
        rospy.loginfo(&#34;Go to goal ({}, {})&#34;.format(goal_x, goal_y))

        distance_to_goal = BotController.compute_distance(
            self._current_x_pos, self._current_y_pos, goal_x, goal_y)

        while not rospy.is_shutdown():
            move_cmd = Twist()
            if distance_to_goal &gt; 0.1:
                distance_to_goal = BotController.compute_distance(self._current_x_pos,
                                                                  self._current_y_pos, goal_x, goal_y)
                # compute the heading
                angle_to_goal = atan2(
                    goal_y - self._current_y_pos, goal_x - self._current_x_pos)

                # rospy.loginfo(&#34;Distance to goal: {}&#34;.format(distance_to_goal))
                # rospy.loginfo(&#34;Angle to goal: {}&#34;.format(angle_to_goal))

                # Make the robot rotate to face the goal
                if angle_to_goal &lt; 0:
                    angle_to_goal = 2 * pi + angle_to_goal

                # compute relative orientation between robot and goal
                w = angle_to_goal - self._current_orientation[2]
                if w &gt; pi:
                    w = w - 2 * pi

                # proportional control for angular velocity
                move_cmd.angular.z = self._kp_angular * w

                # turtlebot max angular velocity is 2.84 rad/s
                if move_cmd.angular.z &gt; 0:
                    move_cmd.angular.z = min(move_cmd.angular.z, 1.5)
                else:
                    move_cmd.angular.z = max(move_cmd.angular.z, -1.5)

                # proportional control for linear velocity
                # turtlebot max linear velocity is 0.22 m/s
                move_cmd.linear.x = min(
                    self._kp_linear * distance_to_goal, 0.6)

                self._velocity_publisher.publish(move_cmd)
                self._rate.sleep()
            else:
                rospy.loginfo(&#34;Goal reached&#34;)
                self._goal_reached = True
                self.run(0, 0)
                return True

    def run(self, linear, angular):
        &#34;&#34;&#34;
        Publish linear and angular velocities to cmd_vel Topic.
        
        Args:
            linear (float): linear velocity
            angular (float): angular velocity
            
        Return:
            None
        &#34;&#34;&#34;
        velocity = Twist()
        velocity.linear.x = linear
        velocity.angular.z = angular
        self._velocity_publisher.publish(velocity)

    def myhook(self):
        &#34;&#34;&#34;
        Function to call when shutting down a Node
        
        Args:
            None
            
        Return:
            None
        &#34;&#34;&#34;
        rospy.loginfo(&#34;shutdown time!&#34;)

            
    def delivery(self):
        &#34;&#34;&#34;
        Perform task of sensing and delivering parts
        to their intended goal
        
        Args:
           None
            
        Return:
            None
        
        &#34;&#34;&#34;
        
        # Identify number of parts in queue
        num_parts = len(self._parts_list)
        
        for i in range(num_parts):
            part_name = self._parts_list[i].part_type
            rospy.loginfo(part_name)
            drop_location = self._parts_list[i].drop_location
                 
            if part_name in self._cam_dict.keys():
                
                # Find camera looking at part
                camera_prt = self._cam_dict[part_name]
                part_by_cam = self._camera_parts[int(camera_prt)-1]
                
                rospy.loginfo(&#34;Part %s is located near camera %s&#34;, part_name, camera_prt)
                
                new_pose = self.get_transform(part_by_cam._frame,&#34;odom&#34;)
                                                            
                goal_x = new_pose.position.x
                goal_y = new_pose.position.y
                
                # Move robot to location of part
                if self.go_to_goal(goal_x, goal_y):
                    rospy.logwarn(&#34;Action completed&#34;)
                    rospy.loginfo(&#34;Robot reached pickup location reached&#34;)
                
                # Attach part to robot
                self.attach_part(part_name)
                
                # Move part to drop location
                if self.go_to_goal(drop_location.x, drop_location.y):
                    rospy.logwarn(&#34;Action completed&#34;)
                    rospy.loginfo(&#34;Drop location reached&#34;)
                
                # Detach part from robot
                self.detach_part(part_name)
            
            else:
                rospy.WARN(&#34;Part not found near any of the four cameras&#34;)
                if i == num_parts-1:
                    rospy.logfatal(&#34;Given Parts can not be found&#34;)
                    rospy.logwarn(&#34;Terminating Program!&#34;)
                    rospy.on_shutdown(self.myhook)
                    sys.exit(1)
                else:
                    continue                
            
        # Return robot to initial position, since parts have been delivered
        if self.go_to_goal(0, 0):
            rospy.logwarn(&#34;Action completed&#34;)
            rospy.on_shutdown(self.myhook)
            sys.exit(1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scripts.bot_controller.bot_controller_class.BotController"><code class="flex name class">
<span>class <span class="ident">BotController</span></span>
<span>(</span><span>rate=10)</span>
</code></dt>
<dd>
<div class="desc"><p>A controller class to drive a turtlebot in Gazebo.</p>
<h2 id="args">Args</h2>
<p>self._is_part_info_gathered: (bool) - sets True if parts info obtained
self._part_list: (list) - stores parts qued to be moved
self._camera_parts: (list) - stores parts sensed by cameras
self._cam_dict: (dict)
- stoes camera number with associated part
self._queried_camera_1: (bool) - sets True if camera data has been processed
self._queried_camera_2: (bool) - sets True if camera data has been processed
self._queried_camera_3: (bool) - sets True if camera data has been processed
self._queried_camera_4: (bool) - sets True if camera data has been processed
self._rate: (rospy.Rate) - used to assign rate to publishing data
self._robot_name: (str) -
stores robot name
self._velocity_msg: (Twist)
-
used to store linear and angular robot velocity
self._kp_linear: (float) -
stores linear proportional controller
self._kp_angular: (float) -
stores angular proportional controller
self._current_x_pos: (float) - stores current robot x position
self._current_y_pos: (float) - stores current robot y position
self._current_orientation: (float) - stores robot current orientation as quaternion
self._initial_orientation: (float) - stores robot initial orientation as quaternion
self._goal_reached: (bool)
-
sets to True when robot reaches goal
self._velocity_publisher: (Twist)
-
publishes robot velocity to cmd_vel
self._camera1_msg: (Rosmsg) -
stores part type, pose, and camera pose info
self._camera2_msg: (Rosmsg) -
stores part type, pose, and camera pose info
self._camera3_msg: (Rosmsg) -
stores part type, pose, and camera pose info
self._camera4_msg: (Rosmsg) -
stores part type, pose, and camera pose info</p>
<h2 id="return">Return</h2>
<p>None</p>
<p>Initializes BotController object with the following attributes</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd><em>description</em>. Defaults to 10.</dd>
</dl>
<h2 id="return_1">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BotController(object):
    &#34;&#34;&#34;
    A controller class to drive a turtlebot in Gazebo.
    
    Args:
        self._is_part_info_gathered: (bool) - sets True if parts info obtained
        self._part_list: (list) - stores parts qued to be moved
        self._camera_parts: (list) - stores parts sensed by cameras
        self._cam_dict: (dict)  - stoes camera number with associated part
        self._queried_camera_1: (bool) - sets True if camera data has been processed
        self._queried_camera_2: (bool) - sets True if camera data has been processed
        self._queried_camera_3: (bool) - sets True if camera data has been processed
        self._queried_camera_4: (bool) - sets True if camera data has been processed
        self._rate: (rospy.Rate) - used to assign rate to publishing data
        self._robot_name: (str) -  stores robot name
        self._velocity_msg: (Twist)  -  used to store linear and angular robot velocity
        self._kp_linear: (float) -  stores linear proportional controller
        self._kp_angular: (float) -  stores angular proportional controller
        self._current_x_pos: (float) - stores current robot x position
        self._current_y_pos: (float) - stores current robot y position
        self._current_orientation: (float) - stores robot current orientation as quaternion
        self._initial_orientation: (float) - stores robot initial orientation as quaternion
        self._goal_reached: (bool)  -  sets to True when robot reaches goal
        self._velocity_publisher: (Twist)  -  publishes robot velocity to cmd_vel
        self._camera1_msg: (Rosmsg) -  stores part type, pose, and camera pose info
        self._camera2_msg: (Rosmsg) -  stores part type, pose, and camera pose info
        self._camera3_msg: (Rosmsg) -  stores part type, pose, and camera pose info
        self._camera4_msg: (Rosmsg) -  stores part type, pose, and camera pose info
        
    Return:
        None
    &#34;&#34;&#34;

    def __init__(self, rate=10):
        &#34;&#34;&#34;
        Initializes BotController object with the following attributes

        Args:
            rate (int, optional): _description_. Defaults to 10.
            
        Return:
            None
        &#34;&#34;&#34;
        
        rospy.init_node(&#39;bot_controller&#39;)
        rospy.loginfo(&#39;Press Ctrl c to exit&#39;)
        self._is_part_info_gathered = False
        self._part_list = []
        self._camera_parts = []
        self._cam_dict = {}

        #  used to check whether a camera data has been processed
        self._queried_camera_1 = False
        self._queried_camera_2 = False
        self._queried_camera_3 = False
        self._queried_camera_4 = False
        
        self._rate = rospy.Rate(rate)
        self._robot_name = &#39;waffle&#39;
        self._velocity_msg = Twist()
        
        #  gains for the proportional controller
        self._kp_linear = 0.2
        self._kp_angular = 0.2

        #  default velocities for going in a straight line
        self._velocity_msg.linear.x = 0.1
        self._velocity_msg.angular.z = 0.1

        # current pose of the robot
        self._current_x_pos = None
        self._current_y_pos = None
        self._current_orientation = None
        self._initial_orientation = None

        #  used to check whether the goal has been reached
        self._goal_reached = False

        # Publishers
        self._velocity_publisher = rospy.Publisher(
            &#39;cmd_vel&#39;, Twist, queue_size=10)
        
        # Subscribers
        self.subscribe()
    
        # Save parts queue from /part_infos
        self._parts_list = self._part_infos_msg.part_infos
        
        # Execute action to deliver parts to their drop location
        self.delivery()
        rospy.spin()

    @staticmethod
    def compute_distance(x1, y1, x2, y2):
        &#34;&#34;&#34;Compute distance between 2 points

        Args:
            x1 (float): x position of the first point
            y1 (float): y position of the first point
            x2 (float): x position of the second point
            y2 (float): y position of the second point

        Returns:
            float: distance between 2 points
        &#34;&#34;&#34;
        return sqrt(((x2-x1)**2) + ((y2-y1)**2))

    @staticmethod
    def get_model_pose(model_name=&#34;waffle&#34;):
        &#34;&#34;&#34;
        Get the pose of the turtlebot in the environment.
        This function is used by the method attach_part

        Args:
            model_name (str, optional): Name of the robot model in Gazebo. Defaults to &#34;waffle&#34;.

        Raises:
            RuntimeError: Raised when the robot model cannot be retrieved

        Returns:
            Pose: Pose of the robot in the Gazebo world
        &#34;&#34;&#34;
        poll_rate = rospy.Rate(1)
        for i in range(10):
            model_states = rospy.wait_for_message(
                &#39;/gazebo/model_states&#39;, ModelStates, 1)
            if model_name in model_states.name:
                model_pose = model_states.pose[model_states.name.index(
                    model_name)]
                break
            poll_rate.sleep()
        else:
            raise RuntimeError(&#39;Failed to get &#39; + model_name + &#39; model state&#39;)
        return model_pose

    def subscribe(self):
        &#34;&#34;&#34;
        Subscribe to /odom, all four cameras, and /part_infos
        
        Args:
            None
            
        Return:
            None 
        &#34;&#34;&#34;
        rospy.Subscriber(&#34;/odom&#34;, Odometry, self.odom_callback)

        rospy.Subscriber(&#34;/logical_camera/camera_1&#34;,
                         LogicalCameraImage, self.camera_1_callback)
        self._camera1_msg = rospy.wait_for_message(&#39;/logical_camera/camera_1&#39;, LogicalCameraImage)
        rospy.loginfo(self._camera1_msg)
        
        if self._camera1_msg is not None:
            model = self._camera1_msg.models[0]
            self._cam_dict[str(model.type)] = &#39;1&#39;
        else:
            self._camera_parts.append(None)

        rospy.Subscriber(&#34;/logical_camera/camera_2&#34;,
                         LogicalCameraImage, self.camera_2_callback)
        self._camera2_msg = rospy.wait_for_message(&#39;/logical_camera/camera_2&#39;, LogicalCameraImage)
        
        rospy.loginfo(self._camera2_msg)
        if self._camera2_msg is not None:
            model = self._camera2_msg.models[0]
            self._cam_dict[str(model.type)] = &#39;2&#39;
        else:
            self._camera_parts.append(None)
            
        rospy.Subscriber(&#34;/logical_camera/camera_3&#34;,
                         LogicalCameraImage, self.camera_3_callback)
        self._camera3_msg = rospy.wait_for_message(&#39;/logical_camera/camera_3&#39;, LogicalCameraImage)
        rospy.loginfo(self._camera3_msg)
        
        if self._camera3_msg is not None:
            model = self._camera3_msg.models[0]
            self._cam_dict[str(model.type)] = &#39;3&#39;
        else:
            self._camera_parts.append(None)
            
        rospy.Subscriber(&#34;/logical_camera/camera_4&#34;,
                         LogicalCameraImage, self.camera_4_callback)
        self._camera4_msg = rospy.wait_for_message(&#39;/logical_camera/camera_4&#39;, LogicalCameraImage)
        rospy.loginfo(self._camera4_msg)
        
        if self._camera4_msg is not None:
            model = self._camera4_msg.models[0]
            self._cam_dict[str(model.type)] = &#39;4&#39;
        else:
            self._camera_parts.append(None)
            
        self._part_infos_msg = rospy.wait_for_message(&#39;/part_infos&#39;, PartInfos)
        rospy.loginfo(self._part_infos_msg)
        
    def attach_part(self, part_type):
        &#34;&#34;&#34;
        Attach a Gazebo model to the turtlebot
        
        Args:
        
            part_type: (str) - type of part to attach
            
        Return:
        
            None
        &#34;&#34;&#34;
        part_name = part_type+&#34;_1&#34;
        rospy.loginfo(part_name)

        pause_physics_client = rospy.ServiceProxy(
            &#39;/gazebo/pause_physics&#39;, Empty)
        unpause_physics_client = rospy.ServiceProxy(
            &#39;/gazebo/unpause_physics&#39;, Empty)
        spawn_sdf_model_client = rospy.ServiceProxy(
            &#39;/gazebo/spawn_sdf_model&#39;, SpawnModel)
        link_attacher_client = rospy.ServiceProxy(
            &#39;/link_attacher_node/attach&#39;, Attach)
        delete_model_client = rospy.ServiceProxy(
            &#39;gazebo/delete_model&#39;, DeleteModel)
        
        # Remove from Gazebo
        delete_model_client(part_type+&#34;_0&#34;)

        # Compute part pose based on current robot pose
        part_pose = BotController.get_model_pose(self._robot_name)
        rospy.loginfo(part_pose.position.x)
        rospy.loginfo(part_pose.position.y)
        rospy.logwarn(self._robot_name)
        # part_pose.position.x -= 0.05
        part_pose.position.y += 0.5
        part_pose.position.z += 0.3

        model_name = &#34;model://&#34;+part_type+&#34;_ariac&#34;
        rospy.loginfo(&#34;Model: {}&#34;.format(model_name))
        
        # Compute spawn model request
        spawn_request = SpawnModelRequest()
        spawn_request.model_name = part_name
        
        # spawn_request.model_name = &#34;assembly_pump_yellow_0&#34;
        spawn_request.model_xml = &#39;&lt;sdf version=&#34;1.6&#34;&gt; \
        &lt;world name=&#34;default&#34;&gt; \
            &lt;include&gt; \
                &lt;uri&gt;{0}&lt;/uri&gt; \
            &lt;/include&gt; \
            &lt;/world&gt; \
        &lt;/sdf&gt;&#39;.format(model_name)
        spawn_request.robot_namespace = self._robot_name
        spawn_request.initial_pose = part_pose

        # Pause Gazebo
        try:
            pause_physics_client()
        except rospy.ServiceException as e:
            rospy.logerr(&#34;Pause physics service call failed: %s&#34;, e)

        spawn_sdf_model_client(spawn_request)

        #  Attach the part to the robot
        try:
            link_attacher_client(
                self._robot_name, &#39;base_footprint&#39;, part_name, &#39;link&#39;)
        except rospy.ServiceException as e:
            rospy.logerr(&#34;Link attacher service call failed: %s&#34;, e)

        #  Unpause Gazebo
        try:
            unpause_physics_client()
        except rospy.ServiceException as e:
            rospy.logerr(&#34;Unpause physics service call failed: %s&#34;, e)

    def detach_part(self, part_type):
        &#34;&#34;&#34;
        Detach a model from the turtlebot
        
        Arg:
            part_type: (str) - name of part type to be detached
            
        Return:
            None
        &#34;&#34;&#34;
        
        detach_client = rospy.ServiceProxy(&#39;/link_attacher_node/detach&#39;,
                                           Attach)
        detach_client.wait_for_service()

        part_name = part_type+&#34;_1&#34;

        # Build the detach request
        rospy.loginfo(&#34;Detaching part from robot&#34;)
        req = AttachRequest()
        req.model_name_1 = self._robot_name
        req.link_name_1 = &#34;base_footprint&#34;
        req.model_name_2 = part_name
        req.link_name_2 = &#34;link&#34;

        detach_client.call(req)

    def camera_1_callback(self, msg):
        &#34;&#34;&#34;
        Callback for Topic /logical_camera/camera_1
        
        Arg:
            msg: (str) - message from /part_info
            
        Return:
            None
        &#34;&#34;&#34;
        
        model = msg.models
        
        if not self._queried_camera_1:
           
            camera_part = Part(
                    model[0].type, &#34;camera_1_&#34;+model[0].type+&#34;_0_frame&#34;, model[0].pose)
            self._camera_parts.append(camera_part)
            self._queried_camera_1 = True

    def camera_2_callback(self, msg): 
        &#34;&#34;&#34;
        Callback for Topic /logical_camera/camera_2
        
        Arg:
            msg: (str) - message from /part_info
            
        Return:
            None
        &#34;&#34;&#34;
        
        model = msg.models
        
        if not self._queried_camera_2:
            
            camera_part = Part(
                    model[0].type, &#34;camera_2_&#34;+ model[0].type+&#34;_0_frame&#34;, model[0].pose)
            self._camera_parts.append(camera_part)
            self._queried_camera_2 = True
            
    def camera_3_callback(self, msg): 
        &#34;&#34;&#34;
        Callback for Topic /logical_camera/camera_3
        
        Arg:
            msg: (str) - message from /part_info
            
        Return:
            None
        &#34;&#34;&#34;
        
        model = msg.models
        
        if not self._queried_camera_3:
            
            camera_part = Part(
                    model[0].type, &#34;camera_3_&#34;+ model[0].type+&#34;_0_frame&#34;, model[0].pose)
            self._camera_parts.append(camera_part)
            self._queried_camera_3 = True
            
    def camera_4_callback(self, msg):
        &#34;&#34;&#34;
        Callback for Topic /logical_camera/camera_4
        
        Arg:
            msg: (str) - message from /part_info
            
        Return:
            None
        &#34;&#34;&#34;
        
        model = msg.models
        
        if not self._queried_camera_4:
            
            camera_part = Part(
                    model[0].type, &#34;camera_4_&#34;+ model[0].type+&#34;_0_frame&#34;, model[0].pose)
            self._camera_parts.append(camera_part)
            self._queried_camera_4 = True
            
    def odom_callback(self, msg):
        &#34;&#34;&#34;
        Callback function for the Topic odom
        
        Args:
            msg (nav_msgs/Odometry): Odometry message
            
        Return:
            None
        &#34;&#34;&#34;
        
        quaternion = (msg.pose.pose.orientation.x, msg.pose.pose.orientation.y,
                      msg.pose.pose.orientation.z, msg.pose.pose.orientation.w)

        self._current_x_pos = msg.pose.pose.position.x
        self._current_y_pos = msg.pose.pose.position.y
        self._current_orientation = euler_from_quaternion(quaternion)

    def get_transform(self, source, target):
        &#34;&#34;&#34;Get the transform between two frames

        Args:
            source (str): source frame
            target (str): target frame

        Returns:
            geometry_msgs/Pose: The pose of the source frame in the target frame
        &#34;&#34;&#34;
        
        tf_buffer = tf2_ros.Buffer(rospy.Duration(3.0))
        tf2_ros.TransformListener(tf_buffer)

        transform_stamped = TransformStamped()

        rospy.logwarn(&#34;Source: {}&#34;.format(source))
        rospy.logwarn(&#34;Target: {}&#34;.format(target))

        try:
            transform_stamped = tf_buffer.lookup_transform(
                target,
                source,
                rospy.Time(),
                rospy.Duration(1.0))
        except (tf2_ros.LookupException,
                tf2_ros.ConnectivityException,
                tf2_ros.ExtrapolationException):
            rospy.logerr(&#34;Unable to lookup transform&#34;)

        pose = Pose()
        pose.position = transform_stamped.transform.translation
        rospy.logwarn(&#34;Transform: {}&#34;.format(pose))
        pose.orientation = transform_stamped.transform.rotation
        return pose

    def go_to_goal(self, goal_x, goal_y):
        &#34;&#34;&#34;
        Make the robot reach a 2D goal using a proportional controller
        
        Args:
            goal_x (float): x position
            goal_y (float): y position
            
        Return:
            None
        &#34;&#34;&#34;
        rospy.loginfo(&#34;Go to goal ({}, {})&#34;.format(goal_x, goal_y))

        distance_to_goal = BotController.compute_distance(
            self._current_x_pos, self._current_y_pos, goal_x, goal_y)

        while not rospy.is_shutdown():
            move_cmd = Twist()
            if distance_to_goal &gt; 0.1:
                distance_to_goal = BotController.compute_distance(self._current_x_pos,
                                                                  self._current_y_pos, goal_x, goal_y)
                # compute the heading
                angle_to_goal = atan2(
                    goal_y - self._current_y_pos, goal_x - self._current_x_pos)

                # rospy.loginfo(&#34;Distance to goal: {}&#34;.format(distance_to_goal))
                # rospy.loginfo(&#34;Angle to goal: {}&#34;.format(angle_to_goal))

                # Make the robot rotate to face the goal
                if angle_to_goal &lt; 0:
                    angle_to_goal = 2 * pi + angle_to_goal

                # compute relative orientation between robot and goal
                w = angle_to_goal - self._current_orientation[2]
                if w &gt; pi:
                    w = w - 2 * pi

                # proportional control for angular velocity
                move_cmd.angular.z = self._kp_angular * w

                # turtlebot max angular velocity is 2.84 rad/s
                if move_cmd.angular.z &gt; 0:
                    move_cmd.angular.z = min(move_cmd.angular.z, 1.5)
                else:
                    move_cmd.angular.z = max(move_cmd.angular.z, -1.5)

                # proportional control for linear velocity
                # turtlebot max linear velocity is 0.22 m/s
                move_cmd.linear.x = min(
                    self._kp_linear * distance_to_goal, 0.6)

                self._velocity_publisher.publish(move_cmd)
                self._rate.sleep()
            else:
                rospy.loginfo(&#34;Goal reached&#34;)
                self._goal_reached = True
                self.run(0, 0)
                return True

    def run(self, linear, angular):
        &#34;&#34;&#34;
        Publish linear and angular velocities to cmd_vel Topic.
        
        Args:
            linear (float): linear velocity
            angular (float): angular velocity
            
        Return:
            None
        &#34;&#34;&#34;
        velocity = Twist()
        velocity.linear.x = linear
        velocity.angular.z = angular
        self._velocity_publisher.publish(velocity)

    def myhook(self):
        &#34;&#34;&#34;
        Function to call when shutting down a Node
        
        Args:
            None
            
        Return:
            None
        &#34;&#34;&#34;
        rospy.loginfo(&#34;shutdown time!&#34;)

            
    def delivery(self):
        &#34;&#34;&#34;
        Perform task of sensing and delivering parts
        to their intended goal
        
        Args:
           None
            
        Return:
            None
        
        &#34;&#34;&#34;
        
        # Identify number of parts in queue
        num_parts = len(self._parts_list)
        
        for i in range(num_parts):
            part_name = self._parts_list[i].part_type
            rospy.loginfo(part_name)
            drop_location = self._parts_list[i].drop_location
                 
            if part_name in self._cam_dict.keys():
                
                # Find camera looking at part
                camera_prt = self._cam_dict[part_name]
                part_by_cam = self._camera_parts[int(camera_prt)-1]
                
                rospy.loginfo(&#34;Part %s is located near camera %s&#34;, part_name, camera_prt)
                
                new_pose = self.get_transform(part_by_cam._frame,&#34;odom&#34;)
                                                            
                goal_x = new_pose.position.x
                goal_y = new_pose.position.y
                
                # Move robot to location of part
                if self.go_to_goal(goal_x, goal_y):
                    rospy.logwarn(&#34;Action completed&#34;)
                    rospy.loginfo(&#34;Robot reached pickup location reached&#34;)
                
                # Attach part to robot
                self.attach_part(part_name)
                
                # Move part to drop location
                if self.go_to_goal(drop_location.x, drop_location.y):
                    rospy.logwarn(&#34;Action completed&#34;)
                    rospy.loginfo(&#34;Drop location reached&#34;)
                
                # Detach part from robot
                self.detach_part(part_name)
            
            else:
                rospy.WARN(&#34;Part not found near any of the four cameras&#34;)
                if i == num_parts-1:
                    rospy.logfatal(&#34;Given Parts can not be found&#34;)
                    rospy.logwarn(&#34;Terminating Program!&#34;)
                    rospy.on_shutdown(self.myhook)
                    sys.exit(1)
                else:
                    continue                
            
        # Return robot to initial position, since parts have been delivered
        if self.go_to_goal(0, 0):
            rospy.logwarn(&#34;Action completed&#34;)
            rospy.on_shutdown(self.myhook)
            sys.exit(1)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="scripts.bot_controller.bot_controller_class.BotController.compute_distance"><code class="name flex">
<span>def <span class="ident">compute_distance</span></span>(<span>x1, y1, x2, y2)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute distance between 2 points</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>float</code></dt>
<dd>x position of the first point</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>float</code></dt>
<dd>y position of the first point</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>float</code></dt>
<dd>x position of the second point</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>float</code></dt>
<dd>y position of the second point</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>distance between 2 points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def compute_distance(x1, y1, x2, y2):
    &#34;&#34;&#34;Compute distance between 2 points

    Args:
        x1 (float): x position of the first point
        y1 (float): y position of the first point
        x2 (float): x position of the second point
        y2 (float): y position of the second point

    Returns:
        float: distance between 2 points
    &#34;&#34;&#34;
    return sqrt(((x2-x1)**2) + ((y2-y1)**2))</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.get_model_pose"><code class="name flex">
<span>def <span class="ident">get_model_pose</span></span>(<span>model_name='waffle')</span>
</code></dt>
<dd>
<div class="desc"><p>Get the pose of the turtlebot in the environment.
This function is used by the method attach_part</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the robot model in Gazebo. Defaults to "waffle".</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>Raised when the robot model cannot be retrieved</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Pose</code></dt>
<dd>Pose of the robot in the Gazebo world</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_model_pose(model_name=&#34;waffle&#34;):
    &#34;&#34;&#34;
    Get the pose of the turtlebot in the environment.
    This function is used by the method attach_part

    Args:
        model_name (str, optional): Name of the robot model in Gazebo. Defaults to &#34;waffle&#34;.

    Raises:
        RuntimeError: Raised when the robot model cannot be retrieved

    Returns:
        Pose: Pose of the robot in the Gazebo world
    &#34;&#34;&#34;
    poll_rate = rospy.Rate(1)
    for i in range(10):
        model_states = rospy.wait_for_message(
            &#39;/gazebo/model_states&#39;, ModelStates, 1)
        if model_name in model_states.name:
            model_pose = model_states.pose[model_states.name.index(
                model_name)]
            break
        poll_rate.sleep()
    else:
        raise RuntimeError(&#39;Failed to get &#39; + model_name + &#39; model state&#39;)
    return model_pose</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scripts.bot_controller.bot_controller_class.BotController.attach_part"><code class="name flex">
<span>def <span class="ident">attach_part</span></span>(<span>self, part_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a Gazebo model to the turtlebot</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>part_type</code></strong></dt>
<dd>(str) - type of part to attach</dd>
</dl>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attach_part(self, part_type):
    &#34;&#34;&#34;
    Attach a Gazebo model to the turtlebot
    
    Args:
    
        part_type: (str) - type of part to attach
        
    Return:
    
        None
    &#34;&#34;&#34;
    part_name = part_type+&#34;_1&#34;
    rospy.loginfo(part_name)

    pause_physics_client = rospy.ServiceProxy(
        &#39;/gazebo/pause_physics&#39;, Empty)
    unpause_physics_client = rospy.ServiceProxy(
        &#39;/gazebo/unpause_physics&#39;, Empty)
    spawn_sdf_model_client = rospy.ServiceProxy(
        &#39;/gazebo/spawn_sdf_model&#39;, SpawnModel)
    link_attacher_client = rospy.ServiceProxy(
        &#39;/link_attacher_node/attach&#39;, Attach)
    delete_model_client = rospy.ServiceProxy(
        &#39;gazebo/delete_model&#39;, DeleteModel)
    
    # Remove from Gazebo
    delete_model_client(part_type+&#34;_0&#34;)

    # Compute part pose based on current robot pose
    part_pose = BotController.get_model_pose(self._robot_name)
    rospy.loginfo(part_pose.position.x)
    rospy.loginfo(part_pose.position.y)
    rospy.logwarn(self._robot_name)
    # part_pose.position.x -= 0.05
    part_pose.position.y += 0.5
    part_pose.position.z += 0.3

    model_name = &#34;model://&#34;+part_type+&#34;_ariac&#34;
    rospy.loginfo(&#34;Model: {}&#34;.format(model_name))
    
    # Compute spawn model request
    spawn_request = SpawnModelRequest()
    spawn_request.model_name = part_name
    
    # spawn_request.model_name = &#34;assembly_pump_yellow_0&#34;
    spawn_request.model_xml = &#39;&lt;sdf version=&#34;1.6&#34;&gt; \
    &lt;world name=&#34;default&#34;&gt; \
        &lt;include&gt; \
            &lt;uri&gt;{0}&lt;/uri&gt; \
        &lt;/include&gt; \
        &lt;/world&gt; \
    &lt;/sdf&gt;&#39;.format(model_name)
    spawn_request.robot_namespace = self._robot_name
    spawn_request.initial_pose = part_pose

    # Pause Gazebo
    try:
        pause_physics_client()
    except rospy.ServiceException as e:
        rospy.logerr(&#34;Pause physics service call failed: %s&#34;, e)

    spawn_sdf_model_client(spawn_request)

    #  Attach the part to the robot
    try:
        link_attacher_client(
            self._robot_name, &#39;base_footprint&#39;, part_name, &#39;link&#39;)
    except rospy.ServiceException as e:
        rospy.logerr(&#34;Link attacher service call failed: %s&#34;, e)

    #  Unpause Gazebo
    try:
        unpause_physics_client()
    except rospy.ServiceException as e:
        rospy.logerr(&#34;Unpause physics service call failed: %s&#34;, e)</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.camera_1_callback"><code class="name flex">
<span>def <span class="ident">camera_1_callback</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for Topic /logical_camera/camera_1</p>
<h2 id="arg">Arg</h2>
<p>msg: (str) - message from /part_info</p>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def camera_1_callback(self, msg):
    &#34;&#34;&#34;
    Callback for Topic /logical_camera/camera_1
    
    Arg:
        msg: (str) - message from /part_info
        
    Return:
        None
    &#34;&#34;&#34;
    
    model = msg.models
    
    if not self._queried_camera_1:
       
        camera_part = Part(
                model[0].type, &#34;camera_1_&#34;+model[0].type+&#34;_0_frame&#34;, model[0].pose)
        self._camera_parts.append(camera_part)
        self._queried_camera_1 = True</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.camera_2_callback"><code class="name flex">
<span>def <span class="ident">camera_2_callback</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for Topic /logical_camera/camera_2</p>
<h2 id="arg">Arg</h2>
<p>msg: (str) - message from /part_info</p>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def camera_2_callback(self, msg): 
    &#34;&#34;&#34;
    Callback for Topic /logical_camera/camera_2
    
    Arg:
        msg: (str) - message from /part_info
        
    Return:
        None
    &#34;&#34;&#34;
    
    model = msg.models
    
    if not self._queried_camera_2:
        
        camera_part = Part(
                model[0].type, &#34;camera_2_&#34;+ model[0].type+&#34;_0_frame&#34;, model[0].pose)
        self._camera_parts.append(camera_part)
        self._queried_camera_2 = True</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.camera_3_callback"><code class="name flex">
<span>def <span class="ident">camera_3_callback</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for Topic /logical_camera/camera_3</p>
<h2 id="arg">Arg</h2>
<p>msg: (str) - message from /part_info</p>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def camera_3_callback(self, msg): 
    &#34;&#34;&#34;
    Callback for Topic /logical_camera/camera_3
    
    Arg:
        msg: (str) - message from /part_info
        
    Return:
        None
    &#34;&#34;&#34;
    
    model = msg.models
    
    if not self._queried_camera_3:
        
        camera_part = Part(
                model[0].type, &#34;camera_3_&#34;+ model[0].type+&#34;_0_frame&#34;, model[0].pose)
        self._camera_parts.append(camera_part)
        self._queried_camera_3 = True</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.camera_4_callback"><code class="name flex">
<span>def <span class="ident">camera_4_callback</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for Topic /logical_camera/camera_4</p>
<h2 id="arg">Arg</h2>
<p>msg: (str) - message from /part_info</p>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def camera_4_callback(self, msg):
    &#34;&#34;&#34;
    Callback for Topic /logical_camera/camera_4
    
    Arg:
        msg: (str) - message from /part_info
        
    Return:
        None
    &#34;&#34;&#34;
    
    model = msg.models
    
    if not self._queried_camera_4:
        
        camera_part = Part(
                model[0].type, &#34;camera_4_&#34;+ model[0].type+&#34;_0_frame&#34;, model[0].pose)
        self._camera_parts.append(camera_part)
        self._queried_camera_4 = True</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.delivery"><code class="name flex">
<span>def <span class="ident">delivery</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform task of sensing and delivering parts
to their intended goal</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delivery(self):
    &#34;&#34;&#34;
    Perform task of sensing and delivering parts
    to their intended goal
    
    Args:
       None
        
    Return:
        None
    
    &#34;&#34;&#34;
    
    # Identify number of parts in queue
    num_parts = len(self._parts_list)
    
    for i in range(num_parts):
        part_name = self._parts_list[i].part_type
        rospy.loginfo(part_name)
        drop_location = self._parts_list[i].drop_location
             
        if part_name in self._cam_dict.keys():
            
            # Find camera looking at part
            camera_prt = self._cam_dict[part_name]
            part_by_cam = self._camera_parts[int(camera_prt)-1]
            
            rospy.loginfo(&#34;Part %s is located near camera %s&#34;, part_name, camera_prt)
            
            new_pose = self.get_transform(part_by_cam._frame,&#34;odom&#34;)
                                                        
            goal_x = new_pose.position.x
            goal_y = new_pose.position.y
            
            # Move robot to location of part
            if self.go_to_goal(goal_x, goal_y):
                rospy.logwarn(&#34;Action completed&#34;)
                rospy.loginfo(&#34;Robot reached pickup location reached&#34;)
            
            # Attach part to robot
            self.attach_part(part_name)
            
            # Move part to drop location
            if self.go_to_goal(drop_location.x, drop_location.y):
                rospy.logwarn(&#34;Action completed&#34;)
                rospy.loginfo(&#34;Drop location reached&#34;)
            
            # Detach part from robot
            self.detach_part(part_name)
        
        else:
            rospy.WARN(&#34;Part not found near any of the four cameras&#34;)
            if i == num_parts-1:
                rospy.logfatal(&#34;Given Parts can not be found&#34;)
                rospy.logwarn(&#34;Terminating Program!&#34;)
                rospy.on_shutdown(self.myhook)
                sys.exit(1)
            else:
                continue                
        
    # Return robot to initial position, since parts have been delivered
    if self.go_to_goal(0, 0):
        rospy.logwarn(&#34;Action completed&#34;)
        rospy.on_shutdown(self.myhook)
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.detach_part"><code class="name flex">
<span>def <span class="ident">detach_part</span></span>(<span>self, part_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Detach a model from the turtlebot</p>
<h2 id="arg">Arg</h2>
<p>part_type: (str) - name of part type to be detached</p>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detach_part(self, part_type):
    &#34;&#34;&#34;
    Detach a model from the turtlebot
    
    Arg:
        part_type: (str) - name of part type to be detached
        
    Return:
        None
    &#34;&#34;&#34;
    
    detach_client = rospy.ServiceProxy(&#39;/link_attacher_node/detach&#39;,
                                       Attach)
    detach_client.wait_for_service()

    part_name = part_type+&#34;_1&#34;

    # Build the detach request
    rospy.loginfo(&#34;Detaching part from robot&#34;)
    req = AttachRequest()
    req.model_name_1 = self._robot_name
    req.link_name_1 = &#34;base_footprint&#34;
    req.model_name_2 = part_name
    req.link_name_2 = &#34;link&#34;

    detach_client.call(req)</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.get_transform"><code class="name flex">
<span>def <span class="ident">get_transform</span></span>(<span>self, source, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the transform between two frames</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>source frame</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>target frame</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>geometry_msgs/Pose: The pose of the source frame in the target frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transform(self, source, target):
    &#34;&#34;&#34;Get the transform between two frames

    Args:
        source (str): source frame
        target (str): target frame

    Returns:
        geometry_msgs/Pose: The pose of the source frame in the target frame
    &#34;&#34;&#34;
    
    tf_buffer = tf2_ros.Buffer(rospy.Duration(3.0))
    tf2_ros.TransformListener(tf_buffer)

    transform_stamped = TransformStamped()

    rospy.logwarn(&#34;Source: {}&#34;.format(source))
    rospy.logwarn(&#34;Target: {}&#34;.format(target))

    try:
        transform_stamped = tf_buffer.lookup_transform(
            target,
            source,
            rospy.Time(),
            rospy.Duration(1.0))
    except (tf2_ros.LookupException,
            tf2_ros.ConnectivityException,
            tf2_ros.ExtrapolationException):
        rospy.logerr(&#34;Unable to lookup transform&#34;)

    pose = Pose()
    pose.position = transform_stamped.transform.translation
    rospy.logwarn(&#34;Transform: {}&#34;.format(pose))
    pose.orientation = transform_stamped.transform.rotation
    return pose</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.go_to_goal"><code class="name flex">
<span>def <span class="ident">go_to_goal</span></span>(<span>self, goal_x, goal_y)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the robot reach a 2D goal using a proportional controller</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>goal_x</code></strong> :&ensp;<code>float</code></dt>
<dd>x position</dd>
<dt><strong><code>goal_y</code></strong> :&ensp;<code>float</code></dt>
<dd>y position</dd>
</dl>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def go_to_goal(self, goal_x, goal_y):
    &#34;&#34;&#34;
    Make the robot reach a 2D goal using a proportional controller
    
    Args:
        goal_x (float): x position
        goal_y (float): y position
        
    Return:
        None
    &#34;&#34;&#34;
    rospy.loginfo(&#34;Go to goal ({}, {})&#34;.format(goal_x, goal_y))

    distance_to_goal = BotController.compute_distance(
        self._current_x_pos, self._current_y_pos, goal_x, goal_y)

    while not rospy.is_shutdown():
        move_cmd = Twist()
        if distance_to_goal &gt; 0.1:
            distance_to_goal = BotController.compute_distance(self._current_x_pos,
                                                              self._current_y_pos, goal_x, goal_y)
            # compute the heading
            angle_to_goal = atan2(
                goal_y - self._current_y_pos, goal_x - self._current_x_pos)

            # rospy.loginfo(&#34;Distance to goal: {}&#34;.format(distance_to_goal))
            # rospy.loginfo(&#34;Angle to goal: {}&#34;.format(angle_to_goal))

            # Make the robot rotate to face the goal
            if angle_to_goal &lt; 0:
                angle_to_goal = 2 * pi + angle_to_goal

            # compute relative orientation between robot and goal
            w = angle_to_goal - self._current_orientation[2]
            if w &gt; pi:
                w = w - 2 * pi

            # proportional control for angular velocity
            move_cmd.angular.z = self._kp_angular * w

            # turtlebot max angular velocity is 2.84 rad/s
            if move_cmd.angular.z &gt; 0:
                move_cmd.angular.z = min(move_cmd.angular.z, 1.5)
            else:
                move_cmd.angular.z = max(move_cmd.angular.z, -1.5)

            # proportional control for linear velocity
            # turtlebot max linear velocity is 0.22 m/s
            move_cmd.linear.x = min(
                self._kp_linear * distance_to_goal, 0.6)

            self._velocity_publisher.publish(move_cmd)
            self._rate.sleep()
        else:
            rospy.loginfo(&#34;Goal reached&#34;)
            self._goal_reached = True
            self.run(0, 0)
            return True</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.myhook"><code class="name flex">
<span>def <span class="ident">myhook</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to call when shutting down a Node</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def myhook(self):
    &#34;&#34;&#34;
    Function to call when shutting down a Node
    
    Args:
        None
        
    Return:
        None
    &#34;&#34;&#34;
    rospy.loginfo(&#34;shutdown time!&#34;)</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.odom_callback"><code class="name flex">
<span>def <span class="ident">odom_callback</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback function for the Topic odom</p>
<h2 id="args">Args</h2>
<p>msg (nav_msgs/Odometry): Odometry message</p>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def odom_callback(self, msg):
    &#34;&#34;&#34;
    Callback function for the Topic odom
    
    Args:
        msg (nav_msgs/Odometry): Odometry message
        
    Return:
        None
    &#34;&#34;&#34;
    
    quaternion = (msg.pose.pose.orientation.x, msg.pose.pose.orientation.y,
                  msg.pose.pose.orientation.z, msg.pose.pose.orientation.w)

    self._current_x_pos = msg.pose.pose.position.x
    self._current_y_pos = msg.pose.pose.position.y
    self._current_orientation = euler_from_quaternion(quaternion)</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, linear, angular)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish linear and angular velocities to cmd_vel Topic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>linear</code></strong> :&ensp;<code>float</code></dt>
<dd>linear velocity</dd>
<dt><strong><code>angular</code></strong> :&ensp;<code>float</code></dt>
<dd>angular velocity</dd>
</dl>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, linear, angular):
    &#34;&#34;&#34;
    Publish linear and angular velocities to cmd_vel Topic.
    
    Args:
        linear (float): linear velocity
        angular (float): angular velocity
        
    Return:
        None
    &#34;&#34;&#34;
    velocity = Twist()
    velocity.linear.x = linear
    velocity.angular.z = angular
    self._velocity_publisher.publish(velocity)</code></pre>
</details>
</dd>
<dt id="scripts.bot_controller.bot_controller_class.BotController.subscribe"><code class="name flex">
<span>def <span class="ident">subscribe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Subscribe to /odom, all four cameras, and /part_infos</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe(self):
    &#34;&#34;&#34;
    Subscribe to /odom, all four cameras, and /part_infos
    
    Args:
        None
        
    Return:
        None 
    &#34;&#34;&#34;
    rospy.Subscriber(&#34;/odom&#34;, Odometry, self.odom_callback)

    rospy.Subscriber(&#34;/logical_camera/camera_1&#34;,
                     LogicalCameraImage, self.camera_1_callback)
    self._camera1_msg = rospy.wait_for_message(&#39;/logical_camera/camera_1&#39;, LogicalCameraImage)
    rospy.loginfo(self._camera1_msg)
    
    if self._camera1_msg is not None:
        model = self._camera1_msg.models[0]
        self._cam_dict[str(model.type)] = &#39;1&#39;
    else:
        self._camera_parts.append(None)

    rospy.Subscriber(&#34;/logical_camera/camera_2&#34;,
                     LogicalCameraImage, self.camera_2_callback)
    self._camera2_msg = rospy.wait_for_message(&#39;/logical_camera/camera_2&#39;, LogicalCameraImage)
    
    rospy.loginfo(self._camera2_msg)
    if self._camera2_msg is not None:
        model = self._camera2_msg.models[0]
        self._cam_dict[str(model.type)] = &#39;2&#39;
    else:
        self._camera_parts.append(None)
        
    rospy.Subscriber(&#34;/logical_camera/camera_3&#34;,
                     LogicalCameraImage, self.camera_3_callback)
    self._camera3_msg = rospy.wait_for_message(&#39;/logical_camera/camera_3&#39;, LogicalCameraImage)
    rospy.loginfo(self._camera3_msg)
    
    if self._camera3_msg is not None:
        model = self._camera3_msg.models[0]
        self._cam_dict[str(model.type)] = &#39;3&#39;
    else:
        self._camera_parts.append(None)
        
    rospy.Subscriber(&#34;/logical_camera/camera_4&#34;,
                     LogicalCameraImage, self.camera_4_callback)
    self._camera4_msg = rospy.wait_for_message(&#39;/logical_camera/camera_4&#39;, LogicalCameraImage)
    rospy.loginfo(self._camera4_msg)
    
    if self._camera4_msg is not None:
        model = self._camera4_msg.models[0]
        self._cam_dict[str(model.type)] = &#39;4&#39;
    else:
        self._camera_parts.append(None)
        
    self._part_infos_msg = rospy.wait_for_message(&#39;/part_infos&#39;, PartInfos)
    rospy.loginfo(self._part_infos_msg)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scripts.bot_controller" href="index.html">scripts.bot_controller</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scripts.bot_controller.bot_controller_class.BotController" href="#scripts.bot_controller.bot_controller_class.BotController">BotController</a></code></h4>
<ul class="two-column">
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.attach_part" href="#scripts.bot_controller.bot_controller_class.BotController.attach_part">attach_part</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.camera_1_callback" href="#scripts.bot_controller.bot_controller_class.BotController.camera_1_callback">camera_1_callback</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.camera_2_callback" href="#scripts.bot_controller.bot_controller_class.BotController.camera_2_callback">camera_2_callback</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.camera_3_callback" href="#scripts.bot_controller.bot_controller_class.BotController.camera_3_callback">camera_3_callback</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.camera_4_callback" href="#scripts.bot_controller.bot_controller_class.BotController.camera_4_callback">camera_4_callback</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.compute_distance" href="#scripts.bot_controller.bot_controller_class.BotController.compute_distance">compute_distance</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.delivery" href="#scripts.bot_controller.bot_controller_class.BotController.delivery">delivery</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.detach_part" href="#scripts.bot_controller.bot_controller_class.BotController.detach_part">detach_part</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.get_model_pose" href="#scripts.bot_controller.bot_controller_class.BotController.get_model_pose">get_model_pose</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.get_transform" href="#scripts.bot_controller.bot_controller_class.BotController.get_transform">get_transform</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.go_to_goal" href="#scripts.bot_controller.bot_controller_class.BotController.go_to_goal">go_to_goal</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.myhook" href="#scripts.bot_controller.bot_controller_class.BotController.myhook">myhook</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.odom_callback" href="#scripts.bot_controller.bot_controller_class.BotController.odom_callback">odom_callback</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.run" href="#scripts.bot_controller.bot_controller_class.BotController.run">run</a></code></li>
<li><code><a title="scripts.bot_controller.bot_controller_class.BotController.subscribe" href="#scripts.bot_controller.bot_controller_class.BotController.subscribe">subscribe</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>